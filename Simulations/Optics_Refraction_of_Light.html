<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Laws of Refraction</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="shortcut icon" href="../files/favicon_white.ico" media="(prefers-color-scheme: dark)" />
    <link rel="shortcut icon" href="../files/favicon.ico" media="(prefers-color-scheme: light)" />
    <link rel="stylesheet" type="text/css" href="../css/style-page.css">
    <style>
        input[type=data] {
            border: 2px solid #049EF4;
            border-radius: 8px;
           text-align: center;
        }

        .label {
            font-weight: bold;
            font-size: 16px;
            margin-left: 0px;;
            
        }
    </style>
    <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-7VWWT4ZKR6"></script>

    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-7VWWT4ZKR6');
    </script>
    <meta name="google-site-verification" content="mz0TRB59UNqdTxhwzmXmGdgVPh8pB4YqjuUr-aWNGIY">

</head>

<body>

    <div id="container">
        <div id="topmenu">
            <div>
                Laws of Refraction</div>

        </div>

        <div id="sidemenu">
            
            <a> Snell's Law: </a><br>
           
            <div class="fraction">
                <span><em>n</em><sub>21</sub></span>
            </div>
            <a>=</a>
            <div class="fraction">
                <span class="fup">sin <em>i</em></span>
                <span class="bar">/</span>
                <span class="fdn">sin <em>r</em></span>
            </div>
            <br>
            <a>where, <em>n</em><sub>21</sub>  <a>Refractive Index,</a></a>

        </div>

        <div id="menu">
            <label for="incident">Angle of Incidence, <em>i</em> =</label><input type="data" id="incidentDisplay"
            size="3"> <a><sup>o</sup></a><br>

        <a><input type="range" id="incident" name="incident" min="0" max="90" value="45" step=".5">
        </a>
        <br><label for="index"> Refractive Index, <em>n</em> =</label><input type="data" id="indexDisplay"
            size="3"><br>

        <a><input type="range" id="index" name="index" min="1" max="3.2" value="1.414" step=".001">
        </a><br>
        <a><label for="refract">Angle of Refraction, <em>r</em> =</label><a id="refractDisplay">
                <input type="data" id="refract" name="refract" min="0" max="90" size="3"
                    onchange="displayRefract()"> </a><sup>o</sup><br>
        </a><br>
            <!-- <a> Refractive Index,</a> <br>
            n<sub>21</sub>=
            <div class="fraction">
                <span class="fup">sin <a id="incidentAngle">i</a></span>
                <span class="bar">/</span>
                <span class="fdn">sin <a id="refractedAngle">r</a></span>
            </div>
            = <a id="refractiveIndex"> </a>
            <br>
            <a id="message-el">
                Angle of Incidence, (i) = <b id="i-el"> 45</b> <br>
                Angle of Refraction, (r) = <b id="r-el">30 </b> <br>
                Refractive Index, ( n<sub>21</sub>) = <b id="n-el"> </b>

            </a>
            <br>
            <button onClick="displayOn()">FORMULA</button>
            <button id="theorybutton" onClick="theorySite()">THEORY</button> -->
        </div>

    </div>
    <script>
        let sideMenu = document.getElementById('sidemenu');
        let theoryButton = document.getElementById('theorybutton');

        function displayOn() {

            if (sideMenu.style.display === 'block') {
                sideMenu.style.display = 'none';
            } else {
                sideMenu.style.display = 'block';
            }
        };

        function theorySite() {

            window.open("../Theory/Optics_Converging_Lens.html", "_self")
        }
    </script>


    <script type="module">
        import * as THREE from '../build/three.module.js';
        import { GLTFLoader } from '../jsm/loaders/GLTFLoader.js';
        import { OrbitControls } from '../jsm/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from '../jsm/renderers/CSS2DRenderer.js';
        import Stats from '../jsm/libs/stats.module.js';
        import g, { GUI } from '../jsm/libs/lil-gui.module.min.js';

        let scene, camera, renderer, controls, labelRenderer;
        let incidentRay, emergentRay, refractedRay;
        let incidentArrow, emergentArrow, refractedArrow;
        let iAngle, r1Angle, r2Angle, eAngle;
        let normalRay1, normalRay2;
        let rayLine, rayArrow, eye;
        const thickness = 5;
        let pointA, pointB, pointC, pointD, normal1, normal2;
        let width = window.innerWidth, height = window.innerHeight;
        let irayLabel, rrayLabel, erayLabel, normal1Label, normal2Label;
        let iangleLabel, r1angleLabel, r2angleLabel, eangleLabel;
        let itext, r1text, r2text, etext;
        let group = new THREE.Group();
        let labelGroup = new THREE.Group();

        let params = {
            i: (Math.PI / 180) * 45,
            r: (Math.PI / 180) * 30,
            n: 1.414,
            ideg: 45,
            rdeg: 30,
        }

        let materialIndex = {
            Air: 1.0003,
            Ice: 1.31,
            Water: 1.33,
            Alcohol: 1.36,
            Kerosene: 1.44,
            Quartz: 1.46,
            Oil: 1.47,
            Benzene: 1.50,
            Glass: 1.52,
            Flint: 1.65,
            Ruby: 1.71,
            Sapphire: 1.77,
            Diamond: 2.42,
            Cinnabar: 3.2
        }

        let incident = document.getElementById('incident');
        let index = document.getElementById('index');
        let refract = document.getElementById('refract');
        let incidentDisplay = document.getElementById('incidentDisplay');
        let indexDisplay = document.getElementById('indexDisplay');
        let refractDisplay = document.getElementById('refractDisplay');
        let X = Math.sin(incident.value * (Math.PI / 180)) / index.value;
        refract.value = ((Math.asin(X) * 180) / Math.PI).toFixed(1);
        incidentDisplay.value = 45;
        indexDisplay.value = params.n;
        let incidentAngle = document.getElementById('incidentAngle');
        let refractedAngle = document.getElementById('refractedAngle');
        // let iEl = document.getElementById('i-el');
        // let rEl = document.getElementById('r-el');
        // let nEl = document.getElementById('n-el');
        // incidentAngle.innerHTML = iEl.innerHTML;
        // refractedAngle.innerHTML = rEl.innerHTML;

        // let refractiveIndex = document.getElementById('refractiveIndex');
        // refractiveIndex.innerHTML = (Math.sin((Math.PI * iEl.innerHTML) / 180) / Math.sin((Math.PI * rEl.innerHTML) / 180)).toFixed(3);
        // nEl.innerHTML = (Math.sin((Math.PI * iEl.innerHTML) / 180) / Math.sin((Math.PI * rEl.innerHTML) / 180)).toFixed(3);


        function createCamera() {
            // Create a Camera
            const fov = 50; // AKA Field of View
            const aspect = width / height;
            const near = 0.1; // the near clipping plane
            const far = 1000; // the far clipping plane

            camera = new THREE.PerspectiveCamera(fov, aspect, near, far);

            camera.position.set(-15, 10, 18);
            // camera.position.set(-10, 3, 40);
        }

        function createLights() {
            // Create a directional light
            const ambientLight = new THREE.HemisphereLight(0xddeeff, 0x202020, .3);
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            scene.add(ambientLight);

            // move the light back and up a bit
            mainLight.position.set(10, 10, 10);

            // remember to add the light to the scene
            scene.add(ambientLight, mainLight);
        }

        function createRenderer() {
            // create the renderer
            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.alpha = true;
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
			
            labelRenderer.domElement.style.pointerEvents = 'none';
            document.body.appendChild(labelRenderer.domElement);
        }

        //ray diagram constructor
        function addRays(length, col) {
            let rayGeometry = new THREE.CylinderBufferGeometry(.05, .05, length).translate(0, length / 2, 0);
            // rayGeometry.rotateX(Math.PI / 2);

            rayLine = new THREE.Mesh(rayGeometry, new THREE.MeshBasicMaterial({ color: col }));
            let coneGeometry = new THREE.ConeGeometry(.3, .5, 6).translate(0, -length / 2, 0);
            coneGeometry.rotateX(Math.PI);
            rayArrow = new THREE.Mesh(coneGeometry, new THREE.MeshBasicMaterial({ color: 'red' }));

            return { rayLine, rayArrow }
        }

        //incident and refracted angle measure and label adjustment with change
        function adjustAngle(ang, start, end, text, value) {
            // console.log( angtext, angLabel );
            ang.geometry.dispose();
            let newangleGeometry = new THREE.RingBufferGeometry(2.1, 2, 11, 1, start, end);
            ang.geometry = newangleGeometry;
            text.innerHTML = value + '&deg;';
        }

        //refracted ray adjusted for various incidence
        function adjustRefract() {
            refractedRay.geometry.dispose();
            let newangleGeometry = new THREE.CylinderBufferGeometry(.05, .05, -thickness / Math.cos(params.r))
                .translate(0, (-thickness / Math.cos(params.r)) / 2, 0);
            refractedRay.geometry = newangleGeometry;
            refractedRay.rotation.set(0, 0, params.r);
        }
        
        function displayRefract() {

            let X = Math.sin(incident.value * (Math.PI / 180)) / index.value;
            let Y = Math.asin(X);

            refract.value = ((Y * 180) / Math.PI).toFixed(1);
            params.i = (Math.PI / 180) * incident.value;
            params.r = Y;
            params.n = index.value;
            params.ideg = incident.value;
            params.rdeg = refract.value;
            incidentDisplay.value = incident.value;
            indexDisplay.value = index.value;
            // change incident and refracted ray and angle measure 
            let A = params.i;
            pointB = new THREE.Vector3(thickness * Math.tan(params.r), 0, 0);
            let B = params.r;
            incidentRay.rotation.set(0, 0, A);
            emergentRay.rotation.set(0, 0, A);
            emergentRay.position.copy(pointB)
            adjustAngle(iAngle, 1.57, A, itext, params.ideg);
            adjustAngle(r1Angle, -1.57, B, r1text, params.rdeg);
            adjustRefract()
            r2Angle.position.copy(pointB);
            eAngle.position.copy(pointB);
            adjustAngle(eAngle, 1.57, B, etext, params.ideg)
            adjustAngle(r2Angle, -1.57, A, r2text, params.rdeg);
            normal2 = new THREE.Vector3(thickness * Math.tan(params.r), -5, 0);
            normalRay2.position.copy(normal2);            
            
            showLabels();
            render()
        }

        function init() {
            scene = new THREE.Scene;
            scene.background = new THREE.Color(0xbfd1e5);

            createCamera();
            createLights();
            createRenderer();


            pointA = new THREE.Vector3(0, 5, 0);
            pointB = new THREE.Vector3(thickness * Math.tan(params.r), 0, 0);
            pointC = new THREE.Vector3(0, 0, 0);
            normal1 = new THREE.Vector3(0, 0, 0);
            normal2 = new THREE.Vector3(thickness * Math.tan(params.r), -5, 0);
            incidentRay = addRays(10, 'blue').rayLine;
            incidentArrow = addRays(10, 'blue').rayArrow;

            let A = params.i;
            iAngle = addAngle(1.57, A);
            iAngle.position.copy(pointA)
            scene.add(iAngle)

            itext = document.createElement('div');
            itext.className = 'label';
            itext.innerHTML = params.ideg + '&deg;';

            iangleLabel = new CSS2DObject(itext);
            iangleLabel.position.copy(new THREE.Vector3(-0.5, 1, 0));
            iAngle.add(iangleLabel);

            incidentRay.rotation.set(0, 0, A);
            incidentRay.position.copy(pointA)
            incidentRay.add(incidentArrow);
            scene.add(incidentRay)

            normalRay1 = addRays(10, 'black').rayLine;
            normalRay1.position.copy(normal1)
            scene.add(normalRay1);

            refractedRay = addRays(-thickness / Math.cos(params.r), 'green').rayLine;
            refractedArrow = addRays(-thickness / Math.cos(params.r), 'green').rayArrow;
            refractedRay.position.copy(pointA);
            let B = params.r;
            refractedRay.rotation.set(0, 0, B);

            r1Angle = addAngle(-1.57, B);
            r2Angle = addAngle(1.57, B);
            r1Angle.position.copy(pointA);
            r2Angle.position.copy(pointB);
            scene.add(r1Angle, r2Angle)
            scene.add(refractedRay);
            refractedRay.add(refractedArrow);

            r1text = document.createElement('div');
            r1text.className = 'label';
            r1text.innerHTML = params.rdeg + '&deg;';

            r1angleLabel = new CSS2DObject(r1text);
            r1angleLabel.position.copy(new THREE.Vector3(0.3, -1.4, 0));
            r1Angle.add(r1angleLabel);
            
            r2text = document.createElement('div');
            r2text.className = 'label';
            r2text.innerHTML = params.rdeg + '&deg;';

            r2angleLabel = new CSS2DObject(r2text);
            r2angleLabel.position.copy(new THREE.Vector3(-0.5, 1.5, 0));
            r2Angle.add(r2angleLabel);

            normalRay2 = addRays(10, 'black').rayLine;
            normalRay2.position.copy(normal2)
            scene.add(normalRay2);

            emergentRay = addRays(-10, 'blue').rayLine;
            emergentArrow = addRays(-10, 'blue').rayArrow;

            eAngle = addAngle(-1.57, A);
            eAngle.position.copy(pointB)
            scene.add(eAngle)
          
            etext = document.createElement('div');
            etext.className = 'label';
            etext.innerHTML = params.ideg + '&deg;';

            eangleLabel = new CSS2DObject(etext);
            eangleLabel.position.copy(new THREE.Vector3(0.5, -1.5, 0));
            eAngle.add(eangleLabel);

            emergentRay.rotation.set(0, 0, A);
            emergentRay.position.copy(pointB)
            emergentRay.add(emergentArrow);
            scene.add(emergentRay)

            let slab = new THREE.Mesh(
                new THREE.BoxGeometry(10, thickness, 5).translate(2, -thickness / 2, 0),
                new THREE.MeshPhongMaterial({
                    color: 0xffff00,
                    transparent: true,
                    opacity: 0.7
                }));
            slab.position.copy(pointA)
            scene.add(slab)
            const scaleHorizontal = new THREE.GridHelper(70, 70);
            scene.add(scaleHorizontal);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enablePan = true;
            controls.enableZoom = true;
            controls.target.set(0, 2, -2);

            showLabels();

            incident.addEventListener('change', function (e) {
                // console.log(e)
                displayRefract();
            })
            index.addEventListener('change', function (e) {
                // console.log(e)
                displayRefract();
            })
            document.body.appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize);
        }

        //the arc representing the incidence and refracted angle
        function addAngle(start, end, value) {
            let angleGeometry = new THREE.RingBufferGeometry(2.1, 2, 11, 1, start, end);
            let angleMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide })
            let angleMeasure = new THREE.Mesh(angleGeometry, angleMaterial);
            
            return angleMeasure
        }

        function showLabels() {
            //labels
            irayLabel = addLabels('Incident Ray');
            erayLabel = addLabels('Emergent Ray');
            rrayLabel = addLabels('Refracted Ray');
            
            normal1Label = addLabels('Normal');
            normal2Label = addLabels('Normal');
            
            irayLabel.position.copy(new THREE.Vector3(0, 8, 0));
            incidentRay.add(irayLabel);

            erayLabel.position.copy(new THREE.Vector3(0, -6, 0));
            emergentRay.add(erayLabel);

            rrayLabel.position.copy(new THREE.Vector3(0, -3, 0));
            refractedRay.add(rrayLabel);


            normal1Label.position.copy(new THREE.Vector3(0, 10, 0));
            normal2Label.position.copy(new THREE.Vector3(0, 0, 0));

            normalRay1.add(normal1Label);
            normalRay2.add(normal2Label);

            // iangleLabel = addLabels(params.ideg + '&deg;').label;
            // itext = addLabels(params.ideg + '&deg;').text;
            
            // iangleLabel.position.copy(new THREE.Vector3(-0.5, 1, 0));
            // iAngle.add(iangleLabel);
            //  angleLabels(eangleLabel, r2angleLabel);
            // eangleLabel.position.copy(new THREE.Vector3(.6, 3.5, 0));
            // normalRay2.add(eangleLabel);

            // r2angleLabel = addLabels(params.rdeg + '&deg;');
            // r2angleLabel.position.copy(new THREE.Vector3(0.5, -1.5, 0));
            // rrayLabel.add(r2angleLabel);
        }

        function angleLabels(obj,value) {
            let text = document.createElement('div');
            text.className = 'label';
            text.innerHTML = value + '&deg;';
            let label = new CSS2DObject(text);
            return 
            // text.textContent = name;
            
            // text.textContent = name;
            
            // label1.position.copy(new THREE.Vector3(-0.5, 1.5, 0));

            // scene.add(label2, label1)
            // return {label1,label2}
            //iangleLabel = addLabels(params.ideg + '&deg;', new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0));
            // eangleLabel = addLabels(params.ideg + '&deg;');
            // r1angleLabel = addLabels('30&deg;', new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, params.r, 0));
            // r2angleLabel = addLabels('30&deg;', new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, -params.r, 0));
            
            // iangleLabel.position.copy(new THREE.Vector3(-0.5, 6.5, 0));
            // normalRay1.add(iangleLabel);

            // r1angleLabel.position.copy(new THREE.Vector3(-0.5, 1.5, 0));
            // rrayLabel.add(r1angleLabel);

            // r2angleLabel.position.copy(new THREE.Vector3(0.5, -1.5, 0));
            // rrayLabel.add(r2angleLabel);

            // eangleLabel.position.copy(new THREE.Vector3(.6, 3.5, 0));
            // normalRay2.add(eangleLabel);

            // 
        }

        //const label for the diagram
        function addLabels(name) {

            let text = document.createElement('div');
            text.className = 'label';
            // text.textContent = name;
            text.innerHTML = name;
            let label = new CSS2DObject(text);
            group.add(label);
            return label
        }

        window.onload = function () {

            init();
            controls.update()
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.rotateSpeed = 0.1;
            animate();
            // guiControls();
            eyeShow();
            // displayRefract();
            // scene.add(new THREE.AmbientLight(0xffffff));  
        }

        function initPoint(data) {
            let pointGeometry = new THREE.BufferGeometry();
            pointGeometry.setAttribute('position', new THREE.BufferAttribute(data.vertices, 3));
            let pointMaterial = data.material;
            let point = new THREE.Points(pointGeometry, pointMaterial);

            point.position.x = data.x;
            point.position.y = data.y;
            point.position.z = data.z;
            return point;
        }

        function render() {

           
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }


        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            render();
        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            render();

        }

        function guiControls() {
            // dat.GUI

            const gui = new GUI({ width: 250 });
            gui.close()

            let lensFolder = gui.addFolder("Lens Focal Length");
            lensFolder.add(params, 'f', 2, 50, 1).name('f (in cm)').onChange((value) => {

                params.f = value;
                let a = ((params.u * params.f) / (params.u + params.f)).toFixed(2);
                params.v = a;
                let b = (a / params.u).toFixed(2);
                params.m = b;
                changeElements(a, b, value, params.u)
            });
            // , Object height(O.H) & Position(u)
            let formulaFolder = gui.addFolder("Adjust Object height & Distance ");
            formulaFolder.add(params, 'h', .5, 5, .1).name('ho (in cm)').onChange((value) => {

                params.h = value;
                changeElements(params.v, params.m, params.f, params.u)
                console.log(params.m)
                // objLabel.position.y = value + value/2;
                // imgLabel.position.y = -params.m*value ;
            });

            formulaFolder.add(object.position, 'z', -100, -1, 1).name('u (in cm)').onChange((value) => {
                params.u = value;
                let a = ((value * params.f) / (value + params.f)).toFixed(2);
                let b = (a / value).toFixed(2);
                params.v = a;
                params.m = b;
                changeElements(a, b, params.f, value);
            });
            let fixedFolder = gui.addFolder("Fixed 'u' values for focal length, f = 5 cm");
            fixedFolder.add(object.position, 'z', uPos).name('u (in cm)').onChange((value) => {
                params.u = value;

                let a = ((value * params.f) / (value + params.f)).toFixed(2);
                let b = (a / value).toFixed(2);
                params.v = a;
                params.m = b;
                changeElements(a, b, params.f, value);
                params.f = 5;
                params.h = 3;

            });

        }

        function changeElements(a, b, c, d) {
            lensFormula(c, params.h, d)
            changeHeight(object, params.h)
            changeHeight(image, params.h)
            adjustCones(objectTip, params.h)
            adjustCones(imageTip, params.h)
            fEl.innerHTML = c;
            uEl.innerHTML = d;
            vEl.innerHTML = a;
            muEl.innerHTML = d;
            mvEl.innerHTML = a;
            mEl.innerHTML = b;
            fmessageEl.innerHTML = c;
            vmessageEl.innerHTML = a;
            umessageEl.innerHTML = d;
            if (Math.abs(params.u) < params.f) {
                image.remove(imgLabel);
                imgLabel = addLabels('Virtual Image');
                image.add(imgLabel);
                incidentArrow1.visible = false;
                incidentArrow2.visible = false;
                incidentArrow3.visible = false;
                reflectedArrow1.visible = false;
                reflectedArrow2.visible = false;
                reflectedArrow3.visible = false;
                incidentRay3.visible = false;
                reflectedRay3.visible = false;
                eye.visible = true;
                let newMaterial = new THREE.MeshBasicMaterial({ color: 'green' });
                reflectedRay1.material = newMaterial;
                reflectedRay2.material = newMaterial;
                reflectedRay3.material = newMaterial;
            } else if (params.f < 4) {
                console.log("short  f")
                reflectedArrow1.visible = false;
                reflectedArrow2.visible = false;
                reflectedArrow3.visible = false;
            } else {
                image.remove(imgLabel);
                imgLabel = addLabels('Real Image');
                image.add(imgLabel);
                eye.visible = false;
                let newMaterial = new THREE.MeshBasicMaterial({ color: 'blue' });
                reflectedRay1.material = newMaterial;
                reflectedRay2.material = newMaterial;
                reflectedRay3.material = newMaterial;
                incidentArrow1.visible = true;
                incidentArrow2.visible = true;
                incidentArrow3.visible = true;
                reflectedArrow1.visible = true;
                reflectedArrow2.visible = true;
                reflectedArrow3.visible = true;
                incidentRay3.visible = true;
                reflectedRay3.visible = true;
                console.log("object distance greater than f")
            }
        }


        function eyeShow() {

            const map1 = new THREE.TextureLoader().load('./assets/img/eyeIconR.png');
            const material1 = new THREE.SpriteMaterial({ map: map1, color: 0xffffff });

            eye = new THREE.Sprite(material1);
            eye.scale.set(5, 5, 5);
            eye.position.set(0, 2, 7);

            scene.add(eye);
            eye.visible = false;
        }
    </script>
</body>

</html>